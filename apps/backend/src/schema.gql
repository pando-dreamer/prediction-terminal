# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input CreateMarketInput {
  category: MarketCategory!
  currentPrice: Float
  description: String!
  expiryDate: DateTime!
  title: String!
}

type DFlowEvent {
  competition: String
  competitionScope: String
  imageUrl: String
  liquidity: Float!
  markets: [DFlowEventMarket!]
  openInterest: Float!
  seriesTicker: String!
  settlementSources: [DFlowSettlementSource!]
  strikeDate: Int
  strikePeriod: String
  subtitle: String!
  ticker: String!
  title: String!
  volume: Float!
  volume24h: Float!
}

type DFlowEventMarket {
  closeTime: Int!
  eventTicker: String!
  expirationTime: Int!
  isActive: Boolean!
  marketType: String!
  noPrice: Float
  noSubTitle: String!
  openInterest: Float!
  openTime: Int!
  result: String
  status: String!
  subtitle: String!
  ticker: String!
  title: String!
  volume: Float!
  yesPrice: Float
  yesSubTitle: String!
}

"""Available sort options for DFlow events"""
enum DFlowEventSort {
  LIQUIDITY
  OPEN_INTEREST
  START_DATE
  VOLUME
  VOLUME_24H
}

type DFlowMarketGraphQL {
  accountsJson: String
  canCloseEarly: Boolean!
  category: String
  closeTime: Float!
  earlyCloseCondition: String
  eventTicker: String!
  expirationTime: Float!
  isActive: Boolean!
  marketType: DFlowMarketType!
  noAsk: Float
  noBid: Float
  noPrice: Float
  noSubTitle: String!
  openInterest: Float!
  openTime: Float!
  result: String
  rulesPrimary: String!
  rulesSecondary: String
  status: DFlowMarketStatus!
  subtitle: String
  ticker: ID!
  timeUntilClose: Float!
  title: String!
  volume: Float!
  yesAsk: Float
  yesBid: Float
  yesPrice: Float
  yesSubTitle: String!
}

enum DFlowMarketStatus {
  ACTIVE
  CANCELLED
  CLOSED
  DETERMINED
  FINALIZED
  INACTIVE
  INITIALIZED
}

enum DFlowMarketType {
  BINARY
  CATEGORICAL
}

type DFlowOrderFill {
  inAmount: String!
  inputMint: String!
  outAmount: String!
  outputMint: String!
  signature: String!
}

type DFlowOrderStatus {
  fills: [DFlowOrderFill!]!
  inAmount: String
  outAmount: String
  status: String!
}

type DFlowOrderbookGraphQL {
  lastPrice: Float!
  noBids: [OrderbookLevel!]!
  sequence: Int!
  spread: Float!
  yesBids: [OrderbookLevel!]!
}

input DFlowQuoteRequestInput {
  amount: String!
  inputMint: String!
  outputMint: String!
  slippageBps: Int!
  userPublicKey: String!
}

type DFlowQuoteResponse {
  computeUnitLimit: Int!
  contextSlot: Int!
  executionMode: String!
  inAmount: String!
  inputMint: String!
  lastValidBlockHeight: Int!
  minOutAmount: String!
  otherAmountThreshold: String!
  outAmount: String!
  outputMint: String!
  platformFee: String
  predictionMarketSlippageBps: Int!
  priceImpactPct: String!
  prioritizationFeeLamports: Int!
  revertMint: String!
  slippageBps: Int!
  transaction: String!
}

type DFlowSettlementSource {
  name: String!
  url: String!
}

input DFlowTradeRequestInput {
  amount: Float!
  direction: String!
  market: String!
  outcome: String!
  slippageBps: Int!
  userPublicKey: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input LoginInput {
  email: String!
  password: String!
}

type Market {
  category: MarketCategory!
  createdAt: DateTime!
  currentPrice: Float!
  description: String!
  expiryDate: DateTime!
  id: ID!
  outcome: Boolean
  resolvedAt: DateTime
  status: MarketStatus!
  title: String!
  totalLiquidity: Float!
  totalVolume: Float!
  updatedAt: DateTime!
}

enum MarketCategory {
  CRYPTO
  ENTERTAINMENT
  OTHER
  POLITICS
  SPORTS
}

type MarketMints {
  baseMint: String!
  marketId: String!
  noMint: String!
  yesMint: String!
}

type MarketQuote {
  lastUpdate: String!
  liquidity: Float!
  marketId: String!
  noPrice: Float!
  volume24h: Float!
  yesPrice: Float!
}

enum MarketStatus {
  ACTIVE
  CLOSED
  RESOLVED
}

type Mutation {
  cancelDFlowOrder(signature: String!): Boolean!
  createMarket(createMarketInput: CreateMarketInput!): Market!
  executeDFlowTrade(request: DFlowTradeRequestInput!): TradeResponse!
  login(loginInput: LoginInput!): User!
  register(registerInput: RegisterInput!): User!
  resolveMarket(id: ID!, outcome: Boolean!): Market!
}

type OrderbookLevel {
  price: Float!
  shares: Float!
  total: Float!
}

type Query {
  activeDFlowEvents(limit: Float): [DFlowEvent!]!
  activeDFlowMarkets(limit: Float): [DFlowMarketGraphQL!]!
  activeMarkets: [Market!]!
  dflowEvent(ticker: ID!): DFlowEvent
  dflowEvents(limit: Float, offset: Float, search: String, sort: DFlowEventSort, status: DFlowMarketStatus, withNestedMarkets: Boolean): [DFlowEvent!]!
  dflowMarket(ticker: ID!): DFlowMarketGraphQL
  dflowMarketMints(marketId: String!): MarketMints!
  dflowMarketQuote(marketId: String!): MarketQuote!
  dflowMarkets(category: String, limit: Float, search: String): [DFlowMarketGraphQL!]!
  dflowOrderStatus(signature: String!): DFlowOrderStatus
  dflowOrderbook(ticker: ID!): DFlowOrderbookGraphQL
  getDFlowQuote(request: DFlowQuoteRequestInput!): DFlowQuoteResponse!
  market(id: ID!): Market!
  markets: [Market!]!
  searchDFlow(limit: Float, offset: Float, query: String!, withNestedAccounts: Boolean, withNestedMarkets: Boolean): [DFlowEvent!]!
  searchDFlowMarkets(limit: Float, query: String!): [DFlowMarketGraphQL!]!
  user(id: ID!): User!
}

input RegisterInput {
  email: String!
  password: String!
  username: String!
}

type TradeResponse {
  error: TradingError
  estimatedGas: Int
  quote: DFlowQuoteResponse
  signature: String
  success: Boolean!
}

type TradingError {
  code: String!
  details: String
  message: String!
  timestamp: String!
}

type User {
  balance: Float!
  createdAt: DateTime!
  email: String!
  id: ID!
  updatedAt: DateTime!
  username: String!
}