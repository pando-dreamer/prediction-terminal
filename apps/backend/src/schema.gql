# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input CreateMarketInput {
  category: MarketCategory!
  currentPrice: Float
  description: String!
  expiryDate: DateTime!
  title: String!
}

type DFlowEvent {
  competition: String
  competitionScope: String
  imageUrl: String
  liquidity: Float!
  markets: [DFlowEventMarket!]
  openInterest: Float!
  seriesTicker: String!
  settlementSources: [DFlowSettlementSource!]
  strikeDate: Int
  strikePeriod: String
  subtitle: String!
  ticker: String!
  title: String!
  volume: Float!
  volume24h: Float!
}

type DFlowEventMarket {
  closeTime: Int!
  eventTicker: String!
  expirationTime: Int!
  isActive: Boolean!
  marketType: String!
  noPrice: Float
  noSubTitle: String!
  openInterest: Float!
  openTime: Int!
  result: String
  status: String!
  subtitle: String!
  ticker: String!
  title: String!
  volume: Float!
  yesPrice: Float
  yesSubTitle: String!
}

"""Available sort options for DFlow events"""
enum DFlowEventSort {
  LIQUIDITY
  OPEN_INTEREST
  START_DATE
  VOLUME
  VOLUME_24H
}

type DFlowMarketGraphQL {
  accountsJson: String
  canCloseEarly: Boolean!
  category: String
  closeTime: Float!
  earlyCloseCondition: String
  eventTicker: String!
  expirationTime: Float!
  isActive: Boolean!
  marketType: DFlowMarketType!
  noAsk: Float
  noBid: Float
  noPrice: Float
  noSubTitle: String!
  openInterest: Float!
  openTime: Float!
  result: String
  rulesPrimary: String!
  rulesSecondary: String
  status: DFlowMarketStatus!
  subtitle: String
  ticker: ID!
  timeUntilClose: Float!
  title: String!
  volume: Float!
  yesAsk: Float
  yesBid: Float
  yesPrice: Float
  yesSubTitle: String!
}

enum DFlowMarketStatus {
  ACTIVE
  CANCELLED
  CLOSED
  DETERMINED
  FINALIZED
  INACTIVE
  INITIALIZED
}

enum DFlowMarketType {
  BINARY
  CATEGORICAL
}

type DFlowOrderFill {
  inAmount: String!
  inputMint: String!
  outAmount: String!
  outputMint: String!
  signature: String!
}

type DFlowOrderStatus {
  fills: [DFlowOrderFill!]!
  inAmount: String
  outAmount: String
  status: String!
}

type DFlowOrderbookGraphQL {
  lastPrice: Float!
  noBids: [OrderbookLevel!]!
  sequence: Int!
  spread: Float!
  yesBids: [OrderbookLevel!]!
}

input DFlowQuoteRequestInput {
  amount: String!
  inputMint: String!
  outputMint: String!
  slippageBps: Int!
  userPublicKey: String!
}

type DFlowQuoteResponse {
  computeUnitLimit: Int!
  contextSlot: Int!
  executionMode: String!
  inAmount: String!
  inputMint: String!
  lastValidBlockHeight: Int!
  minOutAmount: String!
  otherAmountThreshold: String!
  outAmount: String!
  outputMint: String!
  platformFee: String
  predictionMarketSlippageBps: Int!
  priceImpactPct: String!
  prioritizationFeeLamports: Int!
  revertMint: String!
  slippageBps: Int!
  transaction: String!
}

type DFlowSettlementSource {
  name: String!
  url: String!
}

input DFlowTradeRequestInput {
  amount: Float!
  direction: String!
  market: String!
  outcome: String!
  slippageBps: Int!
  userPublicKey: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

enum ExecutionMode {
  ASYNC
  SYNC
}

input LoginInput {
  email: String!
  password: String!
}

type Market {
  category: MarketCategory!
  createdAt: DateTime!
  currentPrice: Float!
  description: String!
  expiryDate: DateTime!
  id: ID!
  outcome: Boolean
  resolvedAt: DateTime
  status: MarketStatus!
  title: String!
  totalLiquidity: Float!
  totalVolume: Float!
  updatedAt: DateTime!
}

enum MarketCategory {
  CRYPTO
  ENTERTAINMENT
  OTHER
  POLITICS
  SPORTS
}

type MarketMints {
  baseMint: String!
  marketId: String!
  noMint: String!
  yesMint: String!
}

type MarketQuote {
  lastUpdate: String!
  liquidity: Float!
  marketId: String!
  noPrice: Float!
  volume24h: Float!
  yesPrice: Float!
}

enum MarketStatus {
  ACTIVE
  CLOSED
  RESOLVED
}

type Mutation {
  cancelDFlowOrder(signature: String!): Boolean!
  createMarket(createMarketInput: CreateMarketInput!): Market!
  createRedemptionOrder(request: RedemptionRequestInput!): RedemptionResult!
  executeDFlowTrade(request: DFlowTradeRequestInput!): TradeResponse!
  login(loginInput: LoginInput!): User!
  redeemPosition(amount: Float, positionId: String!): RedemptionResult!
  refreshUserPositions(walletAddress: String!): RefreshResult!
  register(registerInput: RegisterInput!): User!
  resolveMarket(id: ID!, outcome: Boolean!): Market!
  triggerFullRefresh(walletAddress: String!): RefreshResult!
  triggerFullRefreshAll: [RefreshResult!]!
  updatePortfolioSettings(settings: PortfolioSettingsInput!): Boolean!
  updatePositionPrices(positionIds: [String!]!): Boolean!
}

type OrderbookLevel {
  price: Float!
  shares: Float!
  total: Float!
}

enum OutcomeType {
  NO
  YES
}

type PortfolioHistory {
  createdAt: DateTime!
  cumulativePnL: Float!
  dailyPnL: Float!
  id: ID!
  netDeposits: Float!
  portfolioReturn: Float
  positionCount: Int!
  snapshotDate: DateTime!
  totalValue: Float!
  userId: String!
  walletAddress: String!
  winRate: Float
}

input PortfolioSettingsInput {
  autoRefreshInterval: Int
  emailNotifications: Boolean
  priceAlerts: Boolean
  walletAddress: String!
}

type PortfolioSummary {
  activePositions: Int!
  availableBalance: Float!
  averageHoldingPeriod: Float!
  averagePositionSize: Float!
  dailyPnL: Float!
  diversificationScore: Float!
  largestPosition: Float!
  monthlyPnL: Float!
  netPnL: Float!
  portfolioReturn: Float!
  portfolioRisk: RiskLevel!
  redeemablePositions: Int!
  redeemableValue: Float!
  resolvedPositions: Int!
  totalCostBasis: Float!
  totalPositions: Int!
  totalRealizedPnL: Float!
  totalUnrealizedPnL: Float!
  totalValue: Float!
  weeklyPnL: Float!
  winRate: Float!
}

input PositionFiltersInput {
  marketStatus: String
  minValue: Float
  outcome: String
  redeemableOnly: Boolean
}

enum PositionMarketStatus {
  ACTIVE
  CANCELLED
  RESOLVED
  SETTLED
}

type PositionTrade {
  amount: Float!
  createdAt: DateTime!
  executionMode: ExecutionMode!
  fee: Float!
  id: ID!
  orderId: String
  positionId: String!
  price: Float!
  priceImpact: Float
  slippageBps: Int!
  timestamp: DateTime!
  tradeType: TradeType!
  transactionSignature: String!
}

enum PositionType {
  BINARY
  CATEGORICAL
  PREDICTION
}

type PriceData {
  currentPrice: Float!
  lastUpdated: DateTime!
  marketId: String!
  outcome: String!
  priceChange24h: Float!
  priceChangePercent24h: Float!
  source: String!
  volume24h: Float!
}

type Query {
  activeDFlowEvents(limit: Float): [DFlowEvent!]!
  activeDFlowMarkets(limit: Float): [DFlowMarketGraphQL!]!
  activeMarkets: [Market!]!
  dflowEvent(ticker: ID!): DFlowEvent
  dflowEvents(limit: Float, offset: Float, search: String, sort: DFlowEventSort, status: DFlowMarketStatus, withNestedMarkets: Boolean): [DFlowEvent!]!
  dflowEventsBySeries(limit: Float, offset: Float, seriesTickers: [String!]!, sort: DFlowEventSort, status: DFlowMarketStatus, withNestedMarkets: Boolean): [DFlowEvent!]!
  dflowMarket(ticker: ID!): DFlowMarketGraphQL
  dflowMarketMints(marketId: String!): MarketMints!
  dflowMarketQuote(marketId: String!): MarketQuote!
  dflowMarkets(category: String, limit: Float, search: String): [DFlowMarketGraphQL!]!
  dflowOrderStatus(signature: String!): DFlowOrderStatus
  dflowOrderbook(ticker: ID!): DFlowOrderbookGraphQL
  getDFlowQuote(request: DFlowQuoteRequestInput!): DFlowQuoteResponse!
  market(id: ID!): Market!
  marketPriceHistory(days: Float! = 7, marketId: String!): [PriceData!]!
  markets: [Market!]!
  portfolioHistory(days: Float! = 30, walletAddress: String!): [PortfolioHistory!]!
  portfolioSummary(walletAddress: String!): PortfolioSummary!
  positionHistory(limit: Float! = 50, offset: Float! = 0, positionId: String!): [PositionTrade!]!
  positionPrices(mints: [String!]!): [PriceData!]!
  redeemablePositions(walletAddress: String!): [UserPosition!]!
  redemptionHistory(walletAddress: String!): [RedemptionHistory!]!
  searchDFlow(limit: Float, offset: Float, query: String!, withNestedAccounts: Boolean, withNestedMarkets: Boolean): [DFlowEvent!]!
  searchDFlowMarkets(limit: Float, query: String!): [DFlowMarketGraphQL!]!
  seriesByTags(categories: [String!], limit: Float, offset: Float, tags: [String!]): [SeriesTemplate!]!
  tagsByCategories: TagsByCategoriesResponse!
  user(id: ID!): User!
  userPositions(filters: PositionFiltersInput, walletAddress: String!): [UserPosition!]!
}

type RedemptionHistory {
  amountReceived: Float!
  amountRedeemed: Float!
  createdAt: DateTime!
  id: ID!
  marketResolutionDate: DateTime
  positionId: String!
  profitLoss: Float
  redemptionDate: DateTime!
  transactionSignature: String!
}

input RedemptionRequestInput {
  amount: Float
  positionId: String!
  slippageBps: Int
  userPublicKey: String!
}

type RedemptionResult {
  amountReceived: Float
  amountRedeemed: Float
  error: String
  orderId: String
  success: Boolean!
  transactionSignature: String
}

type RefreshResult {
  errors: [String!]!
  lastRefresh: DateTime!
  positionsFound: Int!
  positionsUpdated: Int!
  success: Boolean!
}

input RegisterInput {
  email: String!
  password: String!
  username: String!
}

enum RiskLevel {
  HIGH
  LOW
  MEDIUM
}

type SeriesTemplate {
  category: String!
  description: String
  frequency: String!
  tags: [String!]!
  ticker: String!
  title: String!
}

type Subscription {
  portfolioUpdates(walletAddress: String!): PortfolioSummary!
  positionUpdates(walletAddress: String!): UserPosition!
  priceUpdates(mints: [String!]!): PriceData!
  redemptionUpdates(walletAddress: String!): RedemptionResult!
}

type TagsByCategoriesResponse {
  tagsByCategories: String!
}

type TradeResponse {
  error: TradingError
  estimatedGas: Int
  quote: DFlowQuoteResponse
  signature: String
  success: Boolean!
}

enum TradeType {
  BUY
  REDEMPTION
  SELL
}

type TradingError {
  code: String!
  details: String
  message: String!
  timestamp: String!
}

type User {
  balance: Float!
  createdAt: DateTime!
  email: String!
  id: ID!
  updatedAt: DateTime!
  username: String!
}

type UserPosition {
  balance: Float!
  balanceRaw: String!
  baseMint: String!
  costBasis: Float
  createdAt: DateTime!
  currentPrice: Float
  daysHeld: Int!
  decimals: Int!
  entryPrice: Float
  estimatedValue: Float
  id: ID!
  isRedeemable: Boolean!
  lastPriceUpdate: DateTime
  marketId: String!
  marketPrice: Float
  marketStatus: PositionMarketStatus!
  marketTitle: String!
  mint: String!
  outcome: OutcomeType!
  positionType: PositionType!
  riskLevel: RiskLevel!
  unrealizedPnL: Float
  unrealizedPnLPercent: Float
  updatedAt: DateTime!
  userId: String!
  walletAddress: String!
}